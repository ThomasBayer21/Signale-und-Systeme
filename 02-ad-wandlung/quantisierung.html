<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantisierung - Zuweisung zu Pegelstufen</title>
    <link rel="stylesheet" href="../styles/common.css">
    <style>
        body {
            background: linear-gradient(135deg, #f0e4f8 0%, #e4d4ec 100%);
        }

        .container {
            max-width: var(--container-width-interactive);
            padding: var(--spacing-xl);
        }

        h1 {
            font-size: 2.2em;
            font-weight: 600;
        }

        /* Kompaktere Controls */
        .control-group {
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        /* Themenfarben für Slider */
        input[type="range"]::-webkit-slider-thumb {
            background: var(--color-ad-wandlung);
        }

        input[type="range"]::-moz-range-thumb {
            background: var(--color-ad-wandlung);
            height: 20px;
            border-radius: 50%;
            background: #b19ac3;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #b19ac3;
            cursor: pointer;
            border: none;
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: #333;
        }

        .canvas-wrapper {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .canvas-wrapper h2 {
            color: #444;
            margin-bottom: 10px;
            font-size: 1.3em;
            text-align: center;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 5px;
            background: white;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card .label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-card .value {
            color: #333;
            font-size: 1.5em;
            font-weight: 700;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Quantisierung</h1>
        <div class="subtitle">Zuweisung zu Pegelstufen - Von kontinuierlich zu diskret</div>

        <div class="info-box">
            <h3>Was ist Quantisierung?</h3>
            <p>
                Die Quantisierung wandelt kontinuierliche Amplitudenwerte in diskrete Stufen um.
                Bei n Bits stehen 2<sup>n</sup> verschiedene Werte zur Verfügung. Der kontinuierliche
                Wert wird auf die nächstgelegene Quantisierungsstufe gerundet.
            </p>
            <p>
                <strong>Quantisierungsrauschen:</strong> Der Fehler zwischen Original und quantisiertem
                Signal. Mit mehr Bits wird dieser Fehler kleiner, aber der Speicherbedarf steigt.
            </p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Anzahl Bits (n):</label>
                <div class="slider-container">
                    <input type="range" id="nBitsSlider" min="1" max="8" value="3" step="1">
                    <span class="value-display" id="nBitsValue">3 Bits</span>
                </div>
            </div>

            <div class="control-group">
                <label>Signalfrequenz (Hz):</label>
                <div class="slider-container">
                    <input type="range" id="frequencySlider" min="0.5" max="5" value="2" step="0.1">
                    <span class="value-display" id="frequencyValue">2.0 Hz</span>
                </div>
            </div>

            <div class="control-group">
                <label>Signaltyp:</label>
                <select id="signalType" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #ddd;">
                    <option value="sine">Sinus</option>
                    <option value="triangle">Dreieck</option>
                    <option value="sawtooth">Sägezahn</option>
                </select>
            </div>
        </div>

        <div class="canvas-wrapper">
            <h2>Quantisierung visualisiert</h2>
            <canvas id="quantizationCanvas" width="1200" height="400"></canvas>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="label">Quantisierungsstufen</div>
                <div class="value" id="levelsValue">8</div>
            </div>
            <div class="stat-card">
                <div class="label">Stufenhöhe</div>
                <div class="value" id="stepSizeValue">0.25</div>
            </div>
            <div class="stat-card">
                <div class="label">Max. Quantisierungsfehler</div>
                <div class="value" id="maxErrorValue">±0.125</div>
            </div>
            <div class="stat-card">
                <div class="label">Signal-to-Noise Ratio</div>
                <div class="value" id="snrValue">18 dB</div>
            </div>
        </div>

        <div class="audio-controls">
            <h4>Hörbares Beispiel</h4>
            <p>Höre den Unterschied im Quantisierungsrauschen zwischen verschiedenen Bitauflösungen</p>
            <p style="font-size: 0.9em; margin-top: 10px; opacity: 0.95;">Es wird immer ein 440 Hz Sinussignal (Kammerton A) abgespielt. Bei wenigen Bits (1-3) hörst du deutliches Rauschen, bei mehr Bits (6-8) wird das Signal sauberer.</p>
            <button class="play-button" id="playBtn" onclick="toggleAudio()">Abspielen (440 Hz Sinussignal)</button>
        </div>

        <div class="export-controls">
            <button class="export-btn" onclick="exportCSV()">Daten als CSV exportieren</button>
            <button class="export-btn" onclick="exportPNG()">Visualisierung speichern</button>
        </div>

        <div class="common-mistake">
            <h4>Wichtig</h4>
            <p>Mehr Bits reduzieren nur das <strong>Quantisierungsrauschen</strong>. Aliasing (zu niedrige Abtastrate) oder andere Verzerrungen werden dadurch nicht behoben!</p>
            <p><strong>Faustregel:</strong> 16 Bit (CD-Qualität) reichen für die meisten Audio-Anwendungen. Mehr Bits bringen nur bei sehr hohem Dynamikumfang (z.B. professionelle Studioaufnahmen) einen Vorteil.</p>
        </div>

        <div class="related-topics">
            <h4>Verwandte Themen</h4>
            <a href="digitale-signalverarbeitung/abtastung_rekonstruktion.html">→ Abtastung & Rekonstruktion (Nyquist-Theorem)</a>
            <a href="../01-analoge-welt/dezibel/amplitude_leistung.html">→ Dezibel-Skala (SNR verstehen)</a>
            <a href="../03-digitale-verarbeitung/digitale_filter.html">→ Digitale Filter (Rauschunterdrückung)</a>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('quantizationCanvas');
        const ctx = canvas.getContext('2d');

        const nBitsSlider = document.getElementById('nBitsSlider');
        const frequencySlider = document.getElementById('frequencySlider');
        const signalTypeSelect = document.getElementById('signalType');

        let nBits = parseInt(nBitsSlider.value);
        let frequency = parseFloat(frequencySlider.value);
        let signalType = signalTypeSelect.value;

        nBitsSlider.addEventListener('input', (e) => {
            nBits = parseInt(e.target.value);
            document.getElementById('nBitsValue').textContent = `${nBits} Bits`;
            updateStats();
            draw();
        });

        frequencySlider.addEventListener('input', (e) => {
            frequency = parseFloat(e.target.value);
            document.getElementById('frequencyValue').textContent = `${frequency.toFixed(1)} Hz`;
            draw();
        });

        signalTypeSelect.addEventListener('change', (e) => {
            signalType = e.target.value;
            draw();
        });

        function generateSignal(t) {
            switch(signalType) {
                case 'sine':
                    return Math.sin(2 * Math.PI * frequency * t);
                case 'triangle':
                    return 2 * Math.abs(2 * (frequency * t - Math.floor(frequency * t + 0.5))) - 1;
                case 'sawtooth':
                    return 2 * (frequency * t - Math.floor(frequency * t + 0.5));
                default:
                    return Math.sin(2 * Math.PI * frequency * t);
            }
        }

        function quantize(value, levels) {
            // Normalisiere auf [0, 1]
            const normalized = (value + 1) / 2;
            // Quantisiere
            const step = 1 / (levels - 1);
            const quantized = Math.round(normalized / step) * step;
            // Zurück zu [-1, 1]
            return quantized * 2 - 1;
        }

        function updateStats() {
            const levels = Math.pow(2, nBits);
            const stepSize = 2 / levels;
            const maxError = stepSize / 2;
            const snr = 6.02 * nBits + 1.76;

            document.getElementById('levelsValue').textContent = levels;
            document.getElementById('stepSizeValue').textContent = stepSize.toFixed(4);
            document.getElementById('maxErrorValue').textContent = `±${maxError.toFixed(4)}`;
            document.getElementById('snrValue').textContent = `${snr.toFixed(1)} dB`;
        }

        function draw() {
            const width = canvas.width;
            const height = canvas.height;
            const margin = 60;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;

            ctx.clearRect(0, 0, width, height);

            // Hintergrund
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            // Koordinatensystem
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.stroke();

            const levels = Math.pow(2, nBits);
            const centerY = margin + plotHeight / 2;

            // Zeichne Quantisierungsstufen
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            for (let i = 0; i < levels; i++) {
                const value = -1 + (2 * i) / (levels - 1);
                const y = centerY - value * (plotHeight / 2) * 0.9;

                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(width - margin, y);
                ctx.stroke();

                // Beschriftung
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(2), margin - 5, y + 3);
            }
            ctx.setLineDash([]);

            // Generiere Signal
            const numSamples = 500;
            const duration = 3;

            // Zeichne Originalsignal
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i <= numSamples; i++) {
                const t = (i / numSamples) * duration;
                const value = generateSignal(t);
                const x = margin + (i / numSamples) * plotWidth;
                const y = centerY - value * (plotHeight / 2) * 0.9;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Zeichne quantisiertes Signal
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= numSamples; i++) {
                const t = (i / numSamples) * duration;
                const value = generateSignal(t);
                const quantizedValue = quantize(value, levels);
                const x = margin + (i / numSamples) * plotWidth;
                const y = centerY - quantizedValue * (plotHeight / 2) * 0.9;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Legende
            ctx.font = '14px Arial';
            ctx.fillStyle = '#3498db';
            ctx.fillText('Original', width - margin - 100, margin + 20);
            ctx.fillStyle = '#e74c3c';
            ctx.fillText(`Quantisiert (${nBits} Bits)`, width - margin - 100, margin + 40);

            // Achsenbeschriftungen
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Zeit (s)', width / 2, height - 20);

            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Amplitude', 0, 0);
            ctx.restore();

            // Zeitachsen-Ticks
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 6; i++) {
                const t = (i / 6) * duration;
                const x = margin + (i / 6) * plotWidth;
                ctx.fillText(t.toFixed(1), x, height - margin + 20);

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, height - margin);
                ctx.lineTo(x, height - margin + 5);
                ctx.stroke();
            }
        }

        updateStats();
        draw();

        // ===== Audio-Wiedergabe =====
        let audioContext = null;
        let oscillator = null;
        let gainNode = null;
        let isPlaying = false;

        function toggleAudio() {
            if (isPlaying) {
                stopAudio();
            } else {
                playQuantizedAudio();
            }
        }

        function playQuantizedAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const sampleRate = audioContext.sampleRate;
            const duration = 3; // 3 Sekunden
            const audioFreq = 440; // A4 Note
            const numSamples = sampleRate * duration;

            // Erstelle Buffer
            const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
            const channelData = buffer.getChannelData(0);

            // Generiere quantisiertes Signal
            const levels = Math.pow(2, nBits);
            for (let i = 0; i < numSamples; i++) {
                const t = i / sampleRate;
                const value = Math.sin(2 * Math.PI * audioFreq * t);
                channelData[i] = quantize(value, levels);
            }

            // Spiele Buffer ab
            const source = audioContext.createBufferSource();
            source.buffer = buffer;

            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.3; // Lautstärke reduzieren

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            source.start(0);
            source.onended = () => {
                stopAudio();
            };

            isPlaying = true;
            const btn = document.getElementById('playBtn');
            btn.textContent = 'Stoppen';
            btn.classList.add('playing');
        }

        function stopAudio() {
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            isPlaying = false;
            const btn = document.getElementById('playBtn');
            btn.textContent = 'Abspielen (440 Hz Ton)';
            btn.classList.remove('playing');
        }

        // ===== Export-Funktionen =====
        function exportCSV() {
            const numSamples = 500;
            const duration = 3;
            const levels = Math.pow(2, nBits);

            let csv = 'Zeit (s),Original,Quantisiert,Fehler\n';

            for (let i = 0; i <= numSamples; i++) {
                const t = (i / numSamples) * duration;
                const original = generateSignal(t);
                const quantized = quantize(original, levels);
                const error = original - quantized;

                csv += `${t.toFixed(6)},${original.toFixed(6)},${quantized.toFixed(6)},${error.toFixed(6)}\n`;
            }

            downloadFile(csv, `quantisierung_${nBits}bit.csv`, 'text/csv');
        }

        function exportPNG() {
            const link = document.createElement('a');
            link.download = `quantisierung_${nBits}bit.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
