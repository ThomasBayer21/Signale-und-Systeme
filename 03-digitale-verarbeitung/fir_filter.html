<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIR-Filter - Finite Impulse Response</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #bcd8e8 0%, #9cbcd8 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .info-box {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 5px;
        }

        .info-box h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .info-box ul {
            margin-left: 20px;
            color: #555;
            line-height: 1.8;
        }

        .controls {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #555;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }

        .value-display {
            min-width: 80px;
            text-align: right;
            font-weight: 600;
            color: #333;
        }

        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .canvas-wrapper.full-width {
            grid-column: 1 / -1;
        }

        .canvas-wrapper h2 {
            color: #444;
            margin-bottom: 10px;
            font-size: 1.3em;
            text-align: center;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 5px;
            background: white;
        }

        select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 14px;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 10px;
        }

        .badge.stable {
            background: #d4edda;
            color: #155724;
        }

        .badge.finite {
            background: #d1ecf1;
            color: #0c5460;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FIR-Filter <span class="badge stable">Immer stabil</span><span class="badge finite">Endlich lang</span></h1>
        <div class="subtitle">Finite Impulse Response - Nicht-rekursive Filterung</div>

        <div class="info-box">
            <h3>Was ist ein FIR-Filter?</h3>
            <p>
                Ein FIR-Filter (Finite Impulse Response) ist ein nicht-rekursives digitales Filter,
                dessen Impulsantwort nach endlich vielen Abtastwerten auf Null abklingt.
            </p>
            <p><strong>Eigenschaften:</strong></p>
            <ul>
                <li><strong>Immer stabil:</strong> Keine Rückkopplung, daher kann das Filter nicht schwingen</li>
                <li><strong>Endliche Impulsdauer:</strong> Die Impulsantwort ist nach N Abtastwerten zu Ende</li>
                <li><strong>Lineare Phase möglich:</strong> Keine Phasenverzerrung bei symmetrischen Koeffizienten</li>
                <li><strong>Einfache Implementierung:</strong> y[n] = Σ h[k] · x[n-k]</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Filtertyp:</label>
                <select id="filterType">
                    <option value="lowpass">Tiefpass (Low-pass)</option>
                    <option value="highpass">Hochpass (High-pass)</option>
                    <option value="bandpass">Bandpass</option>
                    <option value="bandstop">Bandsperre (Notch)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Filterordnung (Anzahl Koeffizienten):</label>
                <div class="slider-container">
                    <input type="range" id="orderSlider" min="5" max="101" value="31" step="2">
                    <span class="value-display" id="orderValue">31</span>
                </div>
            </div>

            <div class="control-group">
                <label>Grenzfrequenz (normalisiert auf fs/2):</label>
                <div class="slider-container">
                    <input type="range" id="cutoffSlider" min="0.05" max="0.95" value="0.3" step="0.01">
                    <span class="value-display" id="cutoffValue">0.30</span>
                </div>
            </div>

            <div class="control-group" id="cutoff2Group" style="display: none;">
                <label>Obere Grenzfrequenz (normalisiert):</label>
                <div class="slider-container">
                    <input type="range" id="cutoff2Slider" min="0.05" max="0.95" value="0.7" step="0.01">
                    <span class="value-display" id="cutoff2Value">0.70</span>
                </div>
            </div>

            <div class="control-group">
                <label>Fensterfunktion:</label>
                <select id="windowType">
                    <option value="rectangular">Rechteck (keine Fensterung)</option>
                    <option value="hamming" selected>Hamming</option>
                    <option value="hanning">Hanning</option>
                    <option value="blackman">Blackman</option>
                </select>
            </div>
        </div>

        <div class="canvas-grid">
            <div class="canvas-wrapper">
                <h2>Impulsantwort h[n]</h2>
                <canvas id="impulseCanvas" width="700" height="350"></canvas>
            </div>

            <div class="canvas-wrapper">
                <h2>Frequenzgang |H(f)|</h2>
                <canvas id="frequencyCanvas" width="700" height="350"></canvas>
            </div>

            <div class="canvas-wrapper full-width">
                <h2>Signalfilterung</h2>
                <canvas id="signalCanvas" width="1400" height="400"></canvas>
            </div>
        </div>
    </div>

    <script>
        const impulseCanvas = document.getElementById('impulseCanvas');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const signalCanvas = document.getElementById('signalCanvas');
        const impulseCtx = impulseCanvas.getContext('2d');
        const frequencyCtx = frequencyCanvas.getContext('2d');
        const signalCtx = signalCanvas.getContext('2d');

        const filterTypeSelect = document.getElementById('filterType');
        const orderSlider = document.getElementById('orderSlider');
        const cutoffSlider = document.getElementById('cutoffSlider');
        const cutoff2Slider = document.getElementById('cutoff2Slider');
        const windowTypeSelect = document.getElementById('windowType');
        const cutoff2Group = document.getElementById('cutoff2Group');

        let filterType = filterTypeSelect.value;
        let order = parseInt(orderSlider.value);
        let cutoff = parseFloat(cutoffSlider.value);
        let cutoff2 = parseFloat(cutoff2Slider.value);
        let windowType = windowTypeSelect.value;

        filterTypeSelect.addEventListener('change', (e) => {
            filterType = e.target.value;
            if (filterType === 'bandpass' || filterType === 'bandstop') {
                cutoff2Group.style.display = 'block';
            } else {
                cutoff2Group.style.display = 'none';
            }
            draw();
        });

        orderSlider.addEventListener('input', (e) => {
            order = parseInt(e.target.value);
            document.getElementById('orderValue').textContent = order;
            draw();
        });

        cutoffSlider.addEventListener('input', (e) => {
            cutoff = parseFloat(e.target.value);
            document.getElementById('cutoffValue').textContent = cutoff.toFixed(2);
            draw();
        });

        cutoff2Slider.addEventListener('input', (e) => {
            cutoff2 = parseFloat(e.target.value);
            document.getElementById('cutoff2Value').textContent = cutoff2.toFixed(2);
            draw();
        });

        windowTypeSelect.addEventListener('change', (e) => {
            windowType = e.target.value;
            draw();
        });

        function sinc(x) {
            if (Math.abs(x) < 1e-10) return 1.0;
            return Math.sin(Math.PI * x) / (Math.PI * x);
        }

        function getWindow(n, N) {
            switch(windowType) {
                case 'hamming':
                    return 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
                case 'hanning':
                    return 0.5 - 0.5 * Math.cos(2 * Math.PI * n / (N - 1));
                case 'blackman':
                    return 0.42 - 0.5 * Math.cos(2 * Math.PI * n / (N - 1)) +
                           0.08 * Math.cos(4 * Math.PI * n / (N - 1));
                default: // rectangular
                    return 1.0;
            }
        }

        function designFIRFilter() {
            const N = order;
            const h = new Array(N);
            const M = (N - 1) / 2;

            for (let n = 0; n < N; n++) {
                let value = 0;
                const nShift = n - M;

                switch(filterType) {
                    case 'lowpass':
                        value = 2 * cutoff * sinc(2 * cutoff * nShift);
                        break;
                    case 'highpass':
                        value = (n === M ? 1 : 0) - 2 * cutoff * sinc(2 * cutoff * nShift);
                        break;
                    case 'bandpass':
                        value = 2 * cutoff2 * sinc(2 * cutoff2 * nShift) -
                                2 * cutoff * sinc(2 * cutoff * nShift);
                        break;
                    case 'bandstop':
                        value = (n === M ? 1 : 0) -
                                (2 * cutoff2 * sinc(2 * cutoff2 * nShift) -
                                 2 * cutoff * sinc(2 * cutoff * nShift));
                        break;
                }

                h[n] = value * getWindow(n, N);
            }

            return h;
        }

        function computeFrequencyResponse(h, numPoints = 512) {
            const response = [];
            for (let k = 0; k < numPoints; k++) {
                const omega = (k / numPoints) * Math.PI;
                let real = 0, imag = 0;

                for (let n = 0; n < h.length; n++) {
                    real += h[n] * Math.cos(omega * n);
                    imag -= h[n] * Math.sin(omega * n);
                }

                const magnitude = Math.sqrt(real * real + imag * imag);
                response.push(magnitude);
            }
            return response;
        }

        function drawImpulseResponse(h) {
            const width = impulseCanvas.width;
            const height = impulseCanvas.height;
            const margin = 50;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;

            impulseCtx.clearRect(0, 0, width, height);
            impulseCtx.fillStyle = '#ffffff';
            impulseCtx.fillRect(0, 0, width, height);

            // Koordinatensystem
            impulseCtx.strokeStyle = '#333';
            impulseCtx.lineWidth = 2;
            impulseCtx.beginPath();
            impulseCtx.moveTo(margin, margin);
            impulseCtx.moveTo(margin, height - margin);
            impulseCtx.lineTo(width - margin, height - margin);
            impulseCtx.stroke();

            const centerY = height - margin;
            const maxH = Math.max(...h.map(Math.abs));
            const scale = (plotHeight * 0.8) / maxH;

            // Nulllinie
            impulseCtx.strokeStyle = '#ddd';
            impulseCtx.lineWidth = 1;
            impulseCtx.beginPath();
            impulseCtx.moveTo(margin, centerY - maxH * scale / 2);
            impulseCtx.lineTo(width - margin, centerY - maxH * scale / 2);
            impulseCtx.stroke();

            // Impulse als Balken
            const barWidth = plotWidth / h.length;
            for (let n = 0; n < h.length; n++) {
                const x = margin + (n / (h.length - 1)) * plotWidth;
                const y = centerY - h[n] * scale;

                impulseCtx.strokeStyle = '#3498db';
                impulseCtx.lineWidth = 2;
                impulseCtx.beginPath();
                impulseCtx.moveTo(x, centerY);
                impulseCtx.lineTo(x, y);
                impulseCtx.stroke();

                impulseCtx.fillStyle = '#3498db';
                impulseCtx.beginPath();
                impulseCtx.arc(x, y, 3, 0, 2 * Math.PI);
                impulseCtx.fill();
            }

            // Beschriftung
            impulseCtx.fillStyle = '#333';
            impulseCtx.font = 'bold 14px Arial';
            impulseCtx.textAlign = 'center';
            impulseCtx.fillText('Sample n', width / 2, height - 10);

            impulseCtx.save();
            impulseCtx.translate(15, height / 2);
            impulseCtx.rotate(-Math.PI / 2);
            impulseCtx.fillText('h[n]', 0, 0);
            impulseCtx.restore();
        }

        function drawFrequencyResponse(response) {
            const width = frequencyCanvas.width;
            const height = frequencyCanvas.height;
            const margin = 50;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;

            frequencyCtx.clearRect(0, 0, width, height);
            frequencyCtx.fillStyle = '#ffffff';
            frequencyCtx.fillRect(0, 0, width, height);

            // Koordinatensystem
            frequencyCtx.strokeStyle = '#333';
            frequencyCtx.lineWidth = 2;
            frequencyCtx.beginPath();
            frequencyCtx.moveTo(margin, margin);
            frequencyCtx.lineTo(margin, height - margin);
            frequencyCtx.lineTo(width - margin, height - margin);
            frequencyCtx.stroke();

            const maxResponse = Math.max(...response);
            const scale = (plotHeight * 0.9) / maxResponse;

            // Frequenzgang
            frequencyCtx.strokeStyle = '#e74c3c';
            frequencyCtx.lineWidth = 2;
            frequencyCtx.beginPath();
            for (let i = 0; i < response.length; i++) {
                const x = margin + (i / (response.length - 1)) * plotWidth;
                const y = height - margin - response[i] * scale;

                if (i === 0) frequencyCtx.moveTo(x, y);
                else frequencyCtx.lineTo(x, y);
            }
            frequencyCtx.stroke();

            // Markiere Grenzfrequenz
            frequencyCtx.strokeStyle = '#27ae60';
            frequencyCtx.lineWidth = 2;
            frequencyCtx.setLineDash([5, 5]);
            const cutoffX = margin + cutoff * plotWidth;
            frequencyCtx.beginPath();
            frequencyCtx.moveTo(cutoffX, margin);
            frequencyCtx.lineTo(cutoffX, height - margin);
            frequencyCtx.stroke();

            if (filterType === 'bandpass' || filterType === 'bandstop') {
                const cutoff2X = margin + cutoff2 * plotWidth;
                frequencyCtx.beginPath();
                frequencyCtx.moveTo(cutoff2X, margin);
                frequencyCtx.lineTo(cutoff2X, height - margin);
                frequencyCtx.stroke();
            }
            frequencyCtx.setLineDash([]);

            // Beschriftung
            frequencyCtx.fillStyle = '#333';
            frequencyCtx.font = 'bold 14px Arial';
            frequencyCtx.textAlign = 'center';
            frequencyCtx.fillText('Normalisierte Frequenz (f/fs)', width / 2, height - 10);

            frequencyCtx.save();
            frequencyCtx.translate(15, height / 2);
            frequencyCtx.rotate(-Math.PI / 2);
            frequencyCtx.fillText('|H(f)|', 0, 0);
            frequencyCtx.restore();

            // Achsenbeschriftungen
            frequencyCtx.fillStyle = '#666';
            frequencyCtx.font = '12px Arial';
            for (let i = 0; i <= 4; i++) {
                const f = i / 8;
                const x = margin + (i / 4) * plotWidth;
                frequencyCtx.fillText(f.toFixed(2), x, height - margin + 20);
            }
        }

        function applyFilter(signal, h) {
            const output = [];
            for (let n = 0; n < signal.length; n++) {
                let sum = 0;
                for (let k = 0; k < h.length; k++) {
                    const idx = n - k;
                    if (idx >= 0) {
                        sum += h[k] * signal[idx];
                    }
                }
                output.push(sum);
            }
            return output;
        }

        function drawSignalFiltering(h) {
            const width = signalCanvas.width;
            const height = signalCanvas.height;
            const margin = 60;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;

            signalCtx.clearRect(0, 0, width, height);
            signalCtx.fillStyle = '#ffffff';
            signalCtx.fillRect(0, 0, width, height);

            // Erzeuge Testsignal (Mehrere Frequenzen)
            const numSamples = 500;
            const signal = [];
            for (let n = 0; n < numSamples; n++) {
                const t = n / numSamples;
                const s = 0.5 * Math.sin(2 * Math.PI * 5 * t) +   // Niedrige Frequenz
                         0.3 * Math.sin(2 * Math.PI * 30 * t) +  // Mittlere Frequenz
                         0.2 * Math.sin(2 * Math.PI * 60 * t);   // Hohe Frequenz
                signal.push(s);
            }

            const filtered = applyFilter(signal, h);

            // Koordinatensystem
            signalCtx.strokeStyle = '#333';
            signalCtx.lineWidth = 2;
            signalCtx.beginPath();
            signalCtx.moveTo(margin, margin);
            signalCtx.lineTo(margin, height - margin);
            signalCtx.lineTo(width - margin, height - margin);
            signalCtx.stroke();

            const centerY = margin + plotHeight / 2;
            const scale = (plotHeight / 2) * 0.8;

            // Nulllinie
            signalCtx.strokeStyle = '#ddd';
            signalCtx.lineWidth = 1;
            signalCtx.beginPath();
            signalCtx.moveTo(margin, centerY);
            signalCtx.lineTo(width - margin, centerY);
            signalCtx.stroke();

            // Originalsignal
            signalCtx.strokeStyle = '#95a5a6';
            signalCtx.lineWidth = 1.5;
            signalCtx.beginPath();
            for (let n = 0; n < signal.length; n++) {
                const x = margin + (n / (signal.length - 1)) * plotWidth;
                const y = centerY - signal[n] * scale;

                if (n === 0) signalCtx.moveTo(x, y);
                else signalCtx.lineTo(x, y);
            }
            signalCtx.stroke();

            // Gefiltertes Signal
            signalCtx.strokeStyle = '#e74c3c';
            signalCtx.lineWidth = 2.5;
            signalCtx.beginPath();
            for (let n = 0; n < filtered.length; n++) {
                const x = margin + (n / (filtered.length - 1)) * plotWidth;
                const y = centerY - filtered[n] * scale;

                if (n === 0) signalCtx.moveTo(x, y);
                else signalCtx.lineTo(x, y);
            }
            signalCtx.stroke();

            // Legende
            signalCtx.font = '14px Arial';
            signalCtx.fillStyle = '#95a5a6';
            signalCtx.textAlign = 'left';
            signalCtx.fillText('Eingangssignal (gemischte Frequenzen)', margin + 20, margin + 20);
            signalCtx.fillStyle = '#e74c3c';
            signalCtx.fillText('Gefilterte Ausgabe', margin + 20, margin + 40);

            // Achsenbeschriftungen
            signalCtx.fillStyle = '#333';
            signalCtx.font = 'bold 14px Arial';
            signalCtx.textAlign = 'center';
            signalCtx.fillText('Sample n', width / 2, height - 20);

            signalCtx.save();
            signalCtx.translate(15, height / 2);
            signalCtx.rotate(-Math.PI / 2);
            signalCtx.fillText('Amplitude', 0, 0);
            signalCtx.restore();
        }

        function draw() {
            const h = designFIRFilter();
            const response = computeFrequencyResponse(h);

            drawImpulseResponse(h);
            drawFrequencyResponse(response);
            drawSignalFiltering(h);
        }

        draw();
    </script>
</body>
</html>
