<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIR-Filter - Infinite Impulse Response</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e8d8bc 0%, #d8c8ac 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .info-box {
            background: #fff8e8;
            border-left: 4px solid #f39c12;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 5px;
        }

        .info-box h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .info-box ul {
            margin-left: 20px;
            color: #555;
            line-height: 1.8;
        }

        .warning-box {
            background: #ffe8e8;
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 5px;
        }

        .warning-box h3 {
            color: #c0392b;
            margin-bottom: 10px;
        }

        .controls {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #555;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f39c12;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f39c12;
            cursor: pointer;
            border: none;
        }

        .value-display {
            min-width: 80px;
            text-align: right;
            font-weight: 600;
            color: #333;
        }

        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .canvas-wrapper.full-width {
            grid-column: 1 / -1;
        }

        .canvas-wrapper h2 {
            color: #444;
            margin-bottom: 10px;
            font-size: 1.3em;
            text-align: center;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 5px;
            background: white;
        }

        select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 14px;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 10px;
        }

        .badge.unstable {
            background: #f8d7da;
            color: #721c24;
        }

        .badge.infinite {
            background: #fff3cd;
            color: #856404;
        }

        .badge.recursive {
            background: #d1ecf1;
            color: #0c5460;
        }

        .stability-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-weight: 600;
        }

        .stability-indicator.stable {
            background: #d4edda;
            color: #155724;
        }

        .stability-indicator.unstable {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>IIR-Filter <span class="badge recursive">Rekursiv</span><span class="badge unstable">Potentiell instabil</span><span class="badge infinite">Theoretisch ∞ lang</span></h1>
        <div class="subtitle">Infinite Impulse Response - Rekursive Filterung</div>

        <div class="info-box">
            <h3>Was ist ein IIR-Filter?</h3>
            <p>
                Ein IIR-Filter (Infinite Impulse Response) ist ein rekursives digitales Filter,
                dessen Impulsantwort theoretisch unendlich lange andauert, da es Rückkopplung verwendet.
            </p>
            <p><strong>Eigenschaften:</strong></p>
            <ul>
                <li><strong>Rekursiv:</strong> Verwendet frühere Ausgangswerte: y[n] = Σ b[k]·x[n-k] - Σ a[k]·y[n-k]</li>
                <li><strong>Potentiell instabil:</strong> Rückkopplung kann zu Schwingungen führen</li>
                <li><strong>Theoretisch unendlich lang:</strong> Die Impulsantwort klingt exponentiell ab</li>
                <li><strong>Effizient:</strong> Weniger Koeffizienten für steile Filter als FIR</li>
                <li><strong>Nichtlineare Phase:</strong> Kann Phasenverzerrungen verursachen</li>
            </ul>
        </div>

        <div class="warning-box">
            <h3>⚠ Stabilitätswarnung</h3>
            <p>
                IIR-Filter können instabil werden, wenn die Pole der Übertragungsfunktion außerhalb
                des Einheitskreises liegen. Ein instabiles Filter schwingt sich auf und produziert
                unbegrenzte Ausgangswerte. Passe die Parameter vorsichtig an!
            </p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Filtertyp:</label>
                <select id="filterType">
                    <option value="butterworth">Butterworth (maximal flach)</option>
                    <option value="chebyshev">Chebyshev (steiler Abfall)</option>
                    <option value="simple">Einfaches 1. Ordnung</option>
                </select>
            </div>

            <div class="control-group">
                <label>Grenzfrequenz (normalisiert auf fs/2):</label>
                <div class="slider-container">
                    <input type="range" id="cutoffSlider" min="0.05" max="0.95" value="0.25" step="0.01">
                    <span class="value-display" id="cutoffValue">0.25</span>
                </div>
            </div>

            <div class="control-group">
                <label>Rückkopplungsstärke (für einfaches Filter):</label>
                <div class="slider-container">
                    <input type="range" id="feedbackSlider" min="0" max="0.95" value="0.7" step="0.01">
                    <span class="value-display" id="feedbackValue">0.70</span>
                </div>
            </div>

            <div class="stability-indicator" id="stabilityIndicator">
                ✓ Filter ist stabil
            </div>
        </div>

        <div class="canvas-grid">
            <div class="canvas-wrapper">
                <h2>Impulsantwort h[n]</h2>
                <canvas id="impulseCanvas" width="700" height="350"></canvas>
            </div>

            <div class="canvas-wrapper">
                <h2>Frequenzgang |H(f)|</h2>
                <canvas id="frequencyCanvas" width="700" height="350"></canvas>
            </div>

            <div class="canvas-wrapper">
                <h2>Pol-Nullstellen-Diagramm</h2>
                <canvas id="poleZeroCanvas" width="700" height="350"></canvas>
            </div>

            <div class="canvas-wrapper">
                <h2>Signalfilterung</h2>
                <canvas id="signalCanvas" width="700" height="350"></canvas>
            </div>
        </div>
    </div>

    <script>
        const impulseCanvas = document.getElementById('impulseCanvas');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const poleZeroCanvas = document.getElementById('poleZeroCanvas');
        const signalCanvas = document.getElementById('signalCanvas');
        const impulseCtx = impulseCanvas.getContext('2d');
        const frequencyCtx = frequencyCanvas.getContext('2d');
        const poleZeroCtx = poleZeroCanvas.getContext('2d');
        const signalCtx = signalCanvas.getContext('2d');

        const filterTypeSelect = document.getElementById('filterType');
        const cutoffSlider = document.getElementById('cutoffSlider');
        const feedbackSlider = document.getElementById('feedbackSlider');
        const stabilityIndicator = document.getElementById('stabilityIndicator');

        let filterType = filterTypeSelect.value;
        let cutoff = parseFloat(cutoffSlider.value);
        let feedback = parseFloat(feedbackSlider.value);

        filterTypeSelect.addEventListener('change', (e) => {
            filterType = e.target.value;
            draw();
        });

        cutoffSlider.addEventListener('input', (e) => {
            cutoff = parseFloat(e.target.value);
            document.getElementById('cutoffValue').textContent = cutoff.toFixed(2);
            draw();
        });

        feedbackSlider.addEventListener('input', (e) => {
            feedback = parseFloat(e.target.value);
            document.getElementById('feedbackValue').textContent = feedback.toFixed(2);
            draw();
        });

        function designIIRFilter() {
            let b, a, poles = [], zeros = [];

            if (filterType === 'simple') {
                // Einfacher 1. Ordnung Tiefpass
                const alpha = 1 - feedback;
                b = [alpha];
                a = [1, -feedback];
                poles = [{real: feedback, imag: 0}];
                zeros = [];
            } else if (filterType === 'butterworth') {
                // Vereinfachter Butterworth 2. Ordnung
                const wc = Math.tan(Math.PI * cutoff);
                const k = wc * wc;
                const sqrt2 = Math.sqrt(2);
                const q = 1 / sqrt2;

                const norm = k + wc / q + 1;
                b = [k / norm, 2 * k / norm, k / norm];
                a = [1, 2 * (k - 1) / norm, (k - wc / q + 1) / norm];

                // Pole berechnen (vereinfacht)
                const angle = Math.PI * (0.25 + 0.5 * cutoff);
                const r = Math.sqrt(-a[2]);
                poles = [
                    {real: r * Math.cos(angle), imag: r * Math.sin(angle)},
                    {real: r * Math.cos(angle), imag: -r * Math.sin(angle)}
                ];
                zeros = [{real: -1, imag: 0}, {real: -1, imag: 0}];
            } else { // chebyshev
                // Vereinfachter Chebyshev 2. Ordnung
                const wc = Math.tan(Math.PI * cutoff);
                const ripple = 0.5; // 0.5 dB Ripple
                const epsilon = Math.sqrt(Math.pow(10, ripple / 10) - 1);
                const k = wc * wc;

                const norm = k + wc * epsilon + 1;
                b = [k / norm, 2 * k / norm, k / norm];
                a = [1, 2 * (k - 1) / norm, (k - wc * epsilon + 1) / norm];

                const angle = Math.PI * (0.2 + 0.6 * cutoff);
                const r = Math.sqrt(-a[2]) * 0.9;
                poles = [
                    {real: r * Math.cos(angle), imag: r * Math.sin(angle)},
                    {real: r * Math.cos(angle), imag: -r * Math.sin(angle)}
                ];
                zeros = [{real: -1, imag: 0}, {real: -1, imag: 0}];
            }

            return {b, a, poles, zeros};
        }

        function checkStability(poles) {
            for (let pole of poles) {
                const magnitude = Math.sqrt(pole.real * pole.real + pole.imag * pole.imag);
                if (magnitude >= 0.999) {
                    return false;
                }
            }
            return true;
        }

        function updateStabilityIndicator(stable) {
            if (stable) {
                stabilityIndicator.className = 'stability-indicator stable';
                stabilityIndicator.textContent = '✓ Filter ist stabil';
            } else {
                stabilityIndicator.className = 'stability-indicator unstable';
                stabilityIndicator.textContent = '⚠ Filter ist INSTABIL!';
            }
        }

        function computeImpulseResponse(b, a, numSamples = 100) {
            const h = new Array(numSamples).fill(0);
            h[0] = b[0];

            for (let n = 1; n < numSamples; n++) {
                let sum = 0;

                // Feedforward Teil
                for (let k = 0; k < b.length && k <= n; k++) {
                    sum += b[k] * (k === 0 ? 1 : (k === n ? 1 : 0));
                }

                // Feedback Teil
                for (let k = 1; k < a.length && k <= n; k++) {
                    sum -= a[k] * h[n - k];
                }

                h[n] = sum;
            }

            return h;
        }

        function computeFrequencyResponse(b, a, numPoints = 512) {
            const response = [];
            for (let k = 0; k < numPoints; k++) {
                const omega = (k / numPoints) * Math.PI;
                let numReal = 0, numImag = 0;
                let denReal = 0, denImag = 0;

                for (let n = 0; n < b.length; n++) {
                    numReal += b[n] * Math.cos(omega * n);
                    numImag -= b[n] * Math.sin(omega * n);
                }

                for (let n = 0; n < a.length; n++) {
                    denReal += a[n] * Math.cos(omega * n);
                    denImag -= a[n] * Math.sin(omega * n);
                }

                const denMag = denReal * denReal + denImag * denImag;
                const real = (numReal * denReal + numImag * denImag) / denMag;
                const imag = (numImag * denReal - numReal * denImag) / denMag;

                const magnitude = Math.sqrt(real * real + imag * imag);
                response.push(magnitude);
            }
            return response;
        }

        function applyIIRFilter(signal, b, a) {
            const output = new Array(signal.length).fill(0);

            for (let n = 0; n < signal.length; n++) {
                let sum = 0;

                // Feedforward
                for (let k = 0; k < b.length; k++) {
                    if (n - k >= 0) {
                        sum += b[k] * signal[n - k];
                    }
                }

                // Feedback
                for (let k = 1; k < a.length; k++) {
                    if (n - k >= 0) {
                        sum -= a[k] * output[n - k];
                    }
                }

                output[n] = sum / a[0];
            }

            return output;
        }

        function drawImpulseResponse(h) {
            const width = impulseCanvas.width;
            const height = impulseCanvas.height;
            const margin = 50;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;

            impulseCtx.clearRect(0, 0, width, height);
            impulseCtx.fillStyle = '#ffffff';
            impulseCtx.fillRect(0, 0, width, height);

            impulseCtx.strokeStyle = '#333';
            impulseCtx.lineWidth = 2;
            impulseCtx.beginPath();
            impulseCtx.moveTo(margin, margin);
            impulseCtx.lineTo(margin, height - margin);
            impulseCtx.lineTo(width - margin, height - margin);
            impulseCtx.stroke();

            const centerY = margin + plotHeight / 2;
            const maxH = Math.max(...h.map(Math.abs), 0.1);
            const scale = (plotHeight / 2) * 0.8 / maxH;

            // Nulllinie
            impulseCtx.strokeStyle = '#ddd';
            impulseCtx.lineWidth = 1;
            impulseCtx.beginPath();
            impulseCtx.moveTo(margin, centerY);
            impulseCtx.lineTo(width - margin, centerY);
            impulseCtx.stroke();

            // Impulsantwort
            for (let n = 0; n < h.length; n++) {
                const x = margin + (n / (h.length - 1)) * plotWidth;
                const y = centerY - h[n] * scale;

                impulseCtx.strokeStyle = '#f39c12';
                impulseCtx.lineWidth = 2;
                impulseCtx.beginPath();
                impulseCtx.moveTo(x, centerY);
                impulseCtx.lineTo(x, y);
                impulseCtx.stroke();

                impulseCtx.fillStyle = '#f39c12';
                impulseCtx.beginPath();
                impulseCtx.arc(x, y, 3, 0, 2 * Math.PI);
                impulseCtx.fill();
            }

            impulseCtx.fillStyle = '#333';
            impulseCtx.font = 'bold 14px Arial';
            impulseCtx.textAlign = 'center';
            impulseCtx.fillText('Sample n', width / 2, height - 10);

            impulseCtx.save();
            impulseCtx.translate(15, height / 2);
            impulseCtx.rotate(-Math.PI / 2);
            impulseCtx.fillText('h[n]', 0, 0);
            impulseCtx.restore();

            // Info: Zeige dass es theoretisch unendlich weitergeht
            impulseCtx.fillStyle = '#999';
            impulseCtx.font = 'italic 12px Arial';
            impulseCtx.textAlign = 'right';
            impulseCtx.fillText('(klingt exponentiell ab...)', width - margin - 10, margin + 20);
        }

        function drawFrequencyResponse(response) {
            const width = frequencyCanvas.width;
            const height = frequencyCanvas.height;
            const margin = 50;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;

            frequencyCtx.clearRect(0, 0, width, height);
            frequencyCtx.fillStyle = '#ffffff';
            frequencyCtx.fillRect(0, 0, width, height);

            frequencyCtx.strokeStyle = '#333';
            frequencyCtx.lineWidth = 2;
            frequencyCtx.beginPath();
            frequencyCtx.moveTo(margin, margin);
            frequencyCtx.lineTo(margin, height - margin);
            frequencyCtx.lineTo(width - margin, height - margin);
            frequencyCtx.stroke();

            const maxResponse = Math.max(...response, 1);
            const scale = (plotHeight * 0.9) / maxResponse;

            frequencyCtx.strokeStyle = '#e74c3c';
            frequencyCtx.lineWidth = 2.5;
            frequencyCtx.beginPath();
            for (let i = 0; i < response.length; i++) {
                const x = margin + (i / (response.length - 1)) * plotWidth;
                const y = height - margin - response[i] * scale;

                if (i === 0) frequencyCtx.moveTo(x, y);
                else frequencyCtx.lineTo(x, y);
            }
            frequencyCtx.stroke();

            // Grenzfrequenz
            frequencyCtx.strokeStyle = '#27ae60';
            frequencyCtx.lineWidth = 2;
            frequencyCtx.setLineDash([5, 5]);
            const cutoffX = margin + cutoff * plotWidth;
            frequencyCtx.beginPath();
            frequencyCtx.moveTo(cutoffX, margin);
            frequencyCtx.lineTo(cutoffX, height - margin);
            frequencyCtx.stroke();
            frequencyCtx.setLineDash([]);

            frequencyCtx.fillStyle = '#333';
            frequencyCtx.font = 'bold 14px Arial';
            frequencyCtx.textAlign = 'center';
            frequencyCtx.fillText('Normalisierte Frequenz (f/fs)', width / 2, height - 10);

            frequencyCtx.save();
            frequencyCtx.translate(15, height / 2);
            frequencyCtx.rotate(-Math.PI / 2);
            frequencyCtx.fillText('|H(f)|', 0, 0);
            frequencyCtx.restore();
        }

        function drawPoleZeroDiagram(poles, zeros) {
            const width = poleZeroCanvas.width;
            const height = poleZeroCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 60;

            poleZeroCtx.clearRect(0, 0, width, height);
            poleZeroCtx.fillStyle = '#ffffff';
            poleZeroCtx.fillRect(0, 0, width, height);

            // Einheitskreis
            poleZeroCtx.strokeStyle = '#3498db';
            poleZeroCtx.lineWidth = 2;
            poleZeroCtx.beginPath();
            poleZeroCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            poleZeroCtx.stroke();

            // Achsen
            poleZeroCtx.strokeStyle = '#ddd';
            poleZeroCtx.lineWidth = 1;
            poleZeroCtx.beginPath();
            poleZeroCtx.moveTo(centerX - radius - 20, centerY);
            poleZeroCtx.lineTo(centerX + radius + 20, centerY);
            poleZeroCtx.moveTo(centerX, centerY - radius - 20);
            poleZeroCtx.lineTo(centerX, centerY + radius + 20);
            poleZeroCtx.stroke();

            // Pole (X)
            poleZeroCtx.strokeStyle = '#e74c3c';
            poleZeroCtx.lineWidth = 3;
            for (let pole of poles) {
                const x = centerX + pole.real * radius;
                const y = centerY - pole.imag * radius;

                poleZeroCtx.beginPath();
                poleZeroCtx.moveTo(x - 8, y - 8);
                poleZeroCtx.lineTo(x + 8, y + 8);
                poleZeroCtx.moveTo(x + 8, y - 8);
                poleZeroCtx.lineTo(x - 8, y + 8);
                poleZeroCtx.stroke();
            }

            // Zeros (O)
            poleZeroCtx.strokeStyle = '#2ecc71';
            poleZeroCtx.lineWidth = 3;
            for (let zero of zeros) {
                const x = centerX + zero.real * radius;
                const y = centerY - zero.imag * radius;

                poleZeroCtx.beginPath();
                poleZeroCtx.arc(x, y, 6, 0, 2 * Math.PI);
                poleZeroCtx.stroke();
            }

            // Legende
            poleZeroCtx.font = '14px Arial';
            poleZeroCtx.textAlign = 'left';

            poleZeroCtx.strokeStyle = '#e74c3c';
            poleZeroCtx.lineWidth = 3;
            poleZeroCtx.beginPath();
            poleZeroCtx.moveTo(20, 20);
            poleZeroCtx.lineTo(35, 35);
            poleZeroCtx.moveTo(35, 20);
            poleZeroCtx.lineTo(20, 35);
            poleZeroCtx.stroke();
            poleZeroCtx.fillStyle = '#333';
            poleZeroCtx.fillText('Pole', 45, 30);

            poleZeroCtx.strokeStyle = '#2ecc71';
            poleZeroCtx.beginPath();
            poleZeroCtx.arc(28, 60, 6, 0, 2 * Math.PI);
            poleZeroCtx.stroke();
            poleZeroCtx.fillText('Nullstellen', 45, 65);

            // Beschriftungen
            poleZeroCtx.fillStyle = '#333';
            poleZeroCtx.font = 'bold 14px Arial';
            poleZeroCtx.textAlign = 'center';
            poleZeroCtx.fillText('Real', width / 2, height - 10);

            poleZeroCtx.save();
            poleZeroCtx.translate(15, height / 2);
            poleZeroCtx.rotate(-Math.PI / 2);
            poleZeroCtx.fillText('Imaginär', 0, 0);
            poleZeroCtx.restore();

            // Stabilitätsinfo
            poleZeroCtx.font = 'italic 12px Arial';
            poleZeroCtx.textAlign = 'center';
            poleZeroCtx.fillStyle = '#3498db';
            poleZeroCtx.fillText('Stabil: Alle Pole innerhalb', width / 2, height - 35);
            poleZeroCtx.fillText('des Einheitskreises', width / 2, height - 20);
        }

        function drawSignalFiltering(b, a) {
            const width = signalCanvas.width;
            const height = signalCanvas.height;
            const margin = 50;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;

            signalCtx.clearRect(0, 0, width, height);
            signalCtx.fillStyle = '#ffffff';
            signalCtx.fillRect(0, 0, width, height);

            // Testsignal
            const numSamples = 300;
            const signal = [];
            for (let n = 0; n < numSamples; n++) {
                const t = n / numSamples;
                const s = 0.5 * Math.sin(2 * Math.PI * 5 * t) +
                         0.3 * Math.sin(2 * Math.PI * 30 * t);
                signal.push(s);
            }

            const filtered = applyIIRFilter(signal, b, a);

            signalCtx.strokeStyle = '#333';
            signalCtx.lineWidth = 2;
            signalCtx.beginPath();
            signalCtx.moveTo(margin, margin);
            signalCtx.lineTo(margin, height - margin);
            signalCtx.lineTo(width - margin, height - margin);
            signalCtx.stroke();

            const centerY = margin + plotHeight / 2;
            const scale = (plotHeight / 2) * 0.8;

            // Nulllinie
            signalCtx.strokeStyle = '#ddd';
            signalCtx.lineWidth = 1;
            signalCtx.beginPath();
            signalCtx.moveTo(margin, centerY);
            signalCtx.lineTo(width - margin, centerY);
            signalCtx.stroke();

            // Original
            signalCtx.strokeStyle = '#95a5a6';
            signalCtx.lineWidth = 1.5;
            signalCtx.beginPath();
            for (let n = 0; n < signal.length; n++) {
                const x = margin + (n / (signal.length - 1)) * plotWidth;
                const y = centerY - signal[n] * scale;
                if (n === 0) signalCtx.moveTo(x, y);
                else signalCtx.lineTo(x, y);
            }
            signalCtx.stroke();

            // Gefiltert
            signalCtx.strokeStyle = '#e74c3c';
            signalCtx.lineWidth = 2.5;
            signalCtx.beginPath();
            for (let n = 0; n < filtered.length; n++) {
                const x = margin + (n / (filtered.length - 1)) * plotWidth;
                const y = centerY - filtered[n] * scale;
                if (n === 0) signalCtx.moveTo(x, y);
                else signalCtx.lineTo(x, y);
            }
            signalCtx.stroke();

            signalCtx.font = '14px Arial';
            signalCtx.fillStyle = '#95a5a6';
            signalCtx.textAlign = 'left';
            signalCtx.fillText('Eingangssignal', margin + 20, margin + 20);
            signalCtx.fillStyle = '#e74c3c';
            signalCtx.fillText('IIR-gefilterte Ausgabe', margin + 20, margin + 40);

            signalCtx.fillStyle = '#333';
            signalCtx.font = 'bold 14px Arial';
            signalCtx.textAlign = 'center';
            signalCtx.fillText('Sample n', width / 2, height - 10);

            signalCtx.save();
            signalCtx.translate(15, height / 2);
            signalCtx.rotate(-Math.PI / 2);
            signalCtx.fillText('Amplitude', 0, 0);
            signalCtx.restore();
        }

        function draw() {
            const {b, a, poles, zeros} = designIIRFilter();
            const stable = checkStability(poles);
            updateStabilityIndicator(stable);

            const h = computeImpulseResponse(b, a);
            const response = computeFrequencyResponse(b, a);

            drawImpulseResponse(h);
            drawFrequencyResponse(response);
            drawPoleZeroDiagram(poles, zeros);
            drawSignalFiltering(b, a);
        }

        draw();
    </script>
</body>
</html>
