<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Korrelation - Digitale Signalverarbeitung</title>
    <link rel="stylesheet" href="../styles/common.css">
    <style>
        body {
            background: linear-gradient(135deg, #d8e8f8 0%, #c8dce8 100%);
        }

        .back-link a {
            color: var(--color-digital);
        }

        .container {
            max-width: var(--container-width-interactive);
            padding: var(--spacing-xl);
        }

        h1 {
            font-size: 2.2em;
            font-weight: 600;
        }

        .subtitle {
            margin-bottom: 25px;
        }

        .formula-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .formula {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            font-size: 1.2em;
            font-family: 'Georgia', serif;
            color: #2c3e50;
            border: 1px solid #d0e8f0;
        }

        .formula-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
            font-family: 'Segoe UI', sans-serif;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            color: #666;
            transition: all 0.3s;
        }

        .tab.active {
            background: #3498db;
            color: white;
        }

        .tab:hover:not(.active) {
            background: #e9ecef;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .controls {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }

        .control-group {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }

        .control-group h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1em;
        }

        label {
            display: block;
            color: #555;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.9em;
        }

        select, input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em;
            background: white;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider-value {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: 600;
            color: #3498db;
            margin-left: 10px;
        }

        canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: white;
        }

        .result-box {
            background: #3498db;
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-top: 15px;
        }

        .result-box .label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .result-box .value {
            font-size: 1.5em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Zurück zur Digitalen Verarbeitung</a>

    <div class="container">
        <h1>Korrelation (Correlation)</h1>
        <div class="subtitle">Ähnlichkeitsbestimmung und Periodizitätserkennung</div>

        <div class="info-box">
            <h3>Was ist Korrelation?</h3>
            <p>Korrelation misst die Ähnlichkeit zwischen Signalen. Im Gegensatz zur Faltung wird das zweite Signal <strong>nicht gespiegelt</strong>. Kreuzkorrelation vergleicht zwei verschiedene Signale, Autokorrelation vergleicht ein Signal mit sich selbst (zeitverschoben).</p>
        </div>

        <div class="formula-grid">
            <div>
                <div class="formula-label">Kreuzkorrelation (Cross-Correlation)</div>
                <div class="formula">R<sub>xy</sub>[m] = Σ x[k] · y[k+m]</div>
            </div>
            <div>
                <div class="formula-label">Autokorrelation (Auto-Correlation)</div>
                <div class="formula">R<sub>xx</sub>[m] = Σ x[k] · x[k+m]</div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" data-tab="cross">Kreuzkorrelation</button>
            <button class="tab" data-tab="auto">Autokorrelation</button>
        </div>

        <div id="cross-tab" class="tab-content active">
            <div class="controls">
                <div class="control-row">
                    <div class="control-group">
                        <h4>Signal x[n]</h4>
                        <label>Signaltyp:</label>
                        <select id="signal1Type">
                            <option value="rect" selected>Rechteckpuls</option>
                            <option value="triangle">Dreieckpuls</option>
                            <option value="sin">Sinusfolge</option>
                            <option value="noise">Rauschen</option>
                            <option value="chirp">Chirp (Frequenzsweep)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <h4>Signal y[n]</h4>
                        <label>Signaltyp:</label>
                        <select id="signal2Type">
                            <option value="rect">Rechteckpuls</option>
                            <option value="triangle" selected>Dreieckpuls</option>
                            <option value="sin">Sinusfolge</option>
                            <option value="noise">Rauschen</option>
                            <option value="chirp">Chirp (Frequenzsweep)</option>
                        </select>
                    </div>
                </div>
                <div class="control-group">
                    <label>Zeitverschiebung m: <span class="slider-value" id="shiftValue">0</span></label>
                    <input type="range" id="shift" min="-20" max="20" value="0" step="1">
                </div>
            </div>

            <canvas id="crossCanvas" width="1200" height="400"></canvas>

            <div class="result-box">
                <div class="label">Kreuzkorrelation bei m = <span id="currentShift">0</span>:</div>
                <div class="value" id="crossValue">0.000</div>
            </div>
        </div>

        <div id="auto-tab" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <h4>Signal x[n]</h4>
                    <label>Signaltyp:</label>
                    <select id="autoSignalType">
                        <option value="sin" selected>Sinusfolge (zeigt Periodizität)</option>
                        <option value="rect">Rechteckpuls</option>
                        <option value="triangle">Dreieckpuls</option>
                        <option value="noise">Rauschen (keine Periodizität)</option>
                        <option value="periodic">Periodisches Rechteck</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Frequenz (für periodische Signale): <span class="slider-value" id="freqValue">4</span> Hz</label>
                    <input type="range" id="frequency" min="1" max="10" value="4" step="1">
                </div>
            </div>

            <canvas id="autoCanvas" width="1200" height="400"></canvas>

            <div class="result-box">
                <div class="label">Maximale Autokorrelation (zeigt Periodizität):</div>
                <div class="value" id="autoMaxValue">1.000</div>
            </div>
        </div>

        <div class="info-box">
            <h3>Unterschied: Korrelation vs. Faltung</h3>
            <p><strong>Korrelation:</strong> R<sub>xy</sub>[m] = Σ x[k] · y[k+m] - Signal y wird <strong>nicht gespiegelt</strong>, nur verschoben</p>
            <p><strong>Faltung:</strong> y[n] = Σ x[k] · h[n-k] - Signal h wird <strong>gespiegelt</strong> (h[-k]) und dann verschoben</p>
            <p><strong>Anwendungen Kreuzkorrelation:</strong> Mustererkennung (Template Matching), Signalverzögerung messen, Radar/Sonar</p>
            <p><strong>Anwendungen Autokorrelation:</strong> Periodizitätserkennung, Pitch Detection (Tonhöhe), Spektralanalyse, Zufälligkeit testen</p>
        </div>


        <div class="related-topics">
            <h4>Verwandte Themen</h4>
            <a href="diskrete_faltung.html">→ Diskrete Faltung (verwandte Operation)</a>
            <a href="frequenzanalyse/fourier_transformation.html">→ Fourier-Transformation (Spektralanalyse)</a>
            <a href="digitale_filter.html">→ Matched Filter (Korrelation)</a>
            <a href="energie-leistung.html#energiesignale">→ Signalenergie und Autokorrelation</a>
        </div>

        <div class="common-mistake">
            <h4>Wichtig</h4>
            <p>Korrelation und Faltung sind <strong>nicht identisch</strong>! Korrelation verschiebt vorwärts, Faltung kehrt um und verschiebt.</p>
            <p>Autokorrelation bei Lag 0 entspricht der <strong>Signalenergie</strong>.</p>
            <p><strong>Anwendung:</strong> Mustersuche, Zeitverzögerungsschätzung, Ähnlichkeitsmessung</p>
        </div>

        <div class="export-controls">
            <button class="export-btn" onclick="exportPNG()">Visualisierung speichern</button>
        </div>
    </div>

    <script>
        const crossCanvas = document.getElementById('crossCanvas');
        const crossCtx = crossCanvas.getContext('2d');
        const autoCanvas = document.getElementById('autoCanvas');
        const autoCtx = autoCanvas.getContext('2d');

        const N = 50; // Signallänge

        // Tab-Steuerung
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        // Signal-Generierung
        function generateSignal(type, N, freq = 4) {
            const signal = [];
            switch(type) {
                case 'rect':
                    for(let i = 0; i < N; i++) {
                        signal.push(i >= N*0.3 && i < N*0.7 ? 1 : 0);
                    }
                    break;
                case 'triangle':
                    const mid = N / 2;
                    for(let i = 0; i < N; i++) {
                        if(i <= mid) {
                            signal.push(i / mid);
                        } else {
                            signal.push((N - i) / (N - mid));
                        }
                    }
                    break;
                case 'sin':
                    for(let i = 0; i < N; i++) {
                        signal.push(Math.sin(2 * Math.PI * freq * i / N));
                    }
                    break;
                case 'noise':
                    for(let i = 0; i < N; i++) {
                        signal.push(Math.random() * 2 - 1);
                    }
                    break;
                case 'chirp':
                    for(let i = 0; i < N; i++) {
                        const f = 1 + (i / N) * 8;
                        signal.push(Math.sin(2 * Math.PI * f * i / N));
                    }
                    break;
                case 'periodic':
                    for(let i = 0; i < N; i++) {
                        const phase = (i % (N / freq)) / (N / freq);
                        signal.push(phase < 0.5 ? 1 : 0);
                    }
                    break;
            }
            return signal;
        }

        // Kreuzkorrelation berechnen
        function crossCorrelation(x, y, m) {
            let sum = 0;
            for(let k = 0; k < x.length; k++) {
                if(k + m >= 0 && k + m < y.length) {
                    sum += x[k] * y[k + m];
                }
            }
            return sum;
        }

        // Autokorrelation berechnen
        function autoCorrelation(x) {
            const result = [];
            const maxLag = Math.floor(x.length / 2);
            for(let m = -maxLag; m <= maxLag; m++) {
                result.push({ m, value: crossCorrelation(x, x, m) });
            }
            return result;
        }

        // Zeichne Kreuzkorrelation
        function drawCrossCorrelation() {
            const x = generateSignal(document.getElementById('signal1Type').value, N);
            const y = generateSignal(document.getElementById('signal2Type').value, N);
            const m = parseInt(document.getElementById('shift').value);

            crossCtx.clearRect(0, 0, crossCanvas.width, crossCanvas.height);

            const panelHeight = 150;
            const margin = 60;

            // Zeichne beide Signale
            drawSignal(crossCtx, x, margin, 50, panelHeight, 'Signal x[n]', '#3498db');
            drawSignal(crossCtx, y, margin, 250, panelHeight, `Signal y[n] (verschoben um m=${m})`, '#e74c3c', m);

            // Berechne und zeichne Korrelation
            const correlationValues = [];
            for(let lag = -20; lag <= 20; lag++) {
                correlationValues.push({ lag, value: crossCorrelation(x, y, lag) });
            }

            drawCorrelationPlot(crossCtx, correlationValues, margin, 450, 150, m);

            // Aktueller Wert
            const currentValue = crossCorrelation(x, y, m);
            document.getElementById('currentShift').textContent = m;
            document.getElementById('crossValue').textContent = currentValue.toFixed(3);
        }

        // Zeichne Autokorrelation
        function drawAutoCorrelation() {
            const freq = parseInt(document.getElementById('frequency').value);
            const x = generateSignal(document.getElementById('autoSignalType').value, N, freq);

            autoCtx.clearRect(0, 0, autoCanvas.width, autoCanvas.height);

            const panelHeight = 150;
            const margin = 60;

            // Zeichne Signal
            drawSignal(autoCtx, x, margin, 50, panelHeight, 'Signal x[n]', '#3498db');

            // Berechne Autokorrelation
            const autoCorr = autoCorrelation(x);

            // Zeichne Autokorrelation
            drawCorrelationPlot(autoCtx, autoCorr.map(r => ({ lag: r.m, value: r.value })), margin, 250, 300);

            // Max-Wert
            const maxVal = Math.max(...autoCorr.map(r => r.value));
            document.getElementById('autoMaxValue').textContent = maxVal.toFixed(3);
        }

        function drawSignal(ctx, signal, margin, yPos, height, title, color, shift = 0) {
            // Titel
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Segoe UI';
            ctx.fillText(title, margin, yPos - 10);

            const barWidth = 15;
            const spacing = (crossCanvas.width - 2 * margin) / signal.length;
            const startX = margin;
            const baseY = yPos + height - 20;

            // Erweiterte Achse für Verschiebung
            const axisExtension = Math.abs(shift) * spacing;
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX - axisExtension, baseY);
            ctx.lineTo(startX + signal.length * spacing + axisExtension, baseY);
            ctx.stroke();

            const maxVal = Math.max(...signal.map(Math.abs), 0.1);
            const scale = (height - 40) / maxVal;

            // Balken mit Verschiebung
            signal.forEach((val, i) => {
                // Position mit Verschiebung: y[k+m] bedeutet Signal nach rechts für positives m
                const xPos = startX + (i + shift) * spacing;
                const barHeight = Math.abs(val) * scale;

                // Nur zeichnen wenn im sichtbaren Bereich
                if(xPos >= startX - spacing && xPos <= startX + signal.length * spacing) {
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.7;
                    ctx.fillRect(xPos, baseY - barHeight, barWidth, barHeight);

                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(xPos, baseY - barHeight, barWidth, barHeight);
                    ctx.globalAlpha = 1.0;

                    // Highlight für Überlappungsbereich
                    if(shift !== 0 && i >= 0 && i < signal.length &&
                       (i + shift) >= 0 && (i + shift) < signal.length) {
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(xPos - 1, baseY - barHeight - 1, barWidth + 2, barHeight + 2);
                    }
                }
            });

            // Verschiebungspfeil zeichnen
            if(shift !== 0) {
                const arrowY = yPos + height + 10;
                const arrowStartX = startX + signal.length * spacing / 2;
                const arrowEndX = arrowStartX + shift * spacing;

                ctx.strokeStyle = '#3498db';
                ctx.fillStyle = '#3498db';
                ctx.lineWidth = 2;

                // Pfeil-Linie
                ctx.beginPath();
                ctx.moveTo(arrowStartX, arrowY);
                ctx.lineTo(arrowEndX, arrowY);
                ctx.stroke();

                // Pfeilspitze
                const arrowSize = 8;
                const direction = shift > 0 ? 1 : -1;
                ctx.beginPath();
                ctx.moveTo(arrowEndX, arrowY);
                ctx.lineTo(arrowEndX - direction * arrowSize, arrowY - arrowSize/2);
                ctx.lineTo(arrowEndX - direction * arrowSize, arrowY + arrowSize/2);
                ctx.closePath();
                ctx.fill();

                // Verschiebungstext
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 12px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(`Verschiebung: ${shift > 0 ? '+' : ''}${shift}`,
                            (arrowStartX + arrowEndX) / 2, arrowY - 8);
            }
        }

        function drawCorrelationPlot(ctx, values, margin, yPos, height, highlight = null) {
            // Titel
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Segoe UI';
            ctx.fillText('Korrelationsfunktion R[m]', margin, yPos - 10);

            const barWidth = 10;
            const spacing = (crossCanvas.width - 2 * margin) / values.length;
            const startX = margin;
            const baseY = yPos + height / 2;

            // Achsen
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, baseY);
            ctx.lineTo(startX + values.length * spacing, baseY);
            ctx.stroke();

            const maxVal = Math.max(...values.map(v => Math.abs(v.value)), 0.1);
            const scale = (height / 2 - 20) / maxVal;

            // Balken
            values.forEach((item, i) => {
                const x = startX + i * spacing;
                const barHeight = Math.abs(item.value) * scale;
                const isNegative = item.value < 0;

                const isHighlight = highlight !== null && item.lag === highlight;

                ctx.fillStyle = isHighlight ? '#3498db' : (item.value >= 0 ? '#3498db' : '#e74c3c');

                if(isNegative) {
                    ctx.fillRect(x, baseY, barWidth, barHeight);
                } else {
                    ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);
                }

                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                if(isNegative) {
                    ctx.strokeRect(x, baseY, barWidth, barHeight);
                } else {
                    ctx.strokeRect(x, baseY - barHeight, barWidth, barHeight);
                }

                // Beschriftung für ausgewählte Punkte
                if(i % 5 === 0 || isHighlight) {
                    ctx.fillStyle = '#555';
                    ctx.font = '10px Segoe UI';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.lag.toString(), x + barWidth/2, baseY + 20);
                }
            });
        }

        // Event-Listener
        document.getElementById('signal1Type').addEventListener('change', drawCrossCorrelation);
        document.getElementById('signal2Type').addEventListener('change', drawCrossCorrelation);
        document.getElementById('shift').addEventListener('input', (e) => {
            document.getElementById('shiftValue').textContent = e.target.value;
            drawCrossCorrelation();
        });

        document.getElementById('autoSignalType').addEventListener('change', drawAutoCorrelation);
        document.getElementById('frequency').addEventListener('input', (e) => {
            document.getElementById('freqValue').textContent = e.target.value;
            drawAutoCorrelation();
        });

        // Initialisierung
        drawCrossCorrelation();
        drawAutoCorrelation();


        // ===== Export-Funktionen =====
        function exportPNG() {
            const canvas = document.querySelector('canvas');
            if (!canvas) return;
            const link = document.createElement('a');
            link.download = 'visualisierung.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
