<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Z-Transformation - Pole und Nullstellen</title>
    <link rel="stylesheet" href="../styles/common.css">
    <style>
        body {
            background: linear-gradient(135deg, #d8e8f8 0%, #c8dce8 100%);
        }

        .container {
            max-width: var(--container-width-interactive);
            padding: var(--spacing-xl);
        }

        h1 {
            font-size: 2.2em;
            font-weight: 600;
        }
        .subtitle {
            margin-bottom: 25px;
        }

        .back-link a {
            color: var(--color-digital);
        }
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            align-items: start;
        }
        .panel {
            background: #fafafa;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
        }
        .panel h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        .panel.compact {
            padding: 15px;
        }
        .panel.compact h3 {
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .panel.compact canvas {
            margin: 10px auto;
        }
        .panel.compact .stability-indicator {
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .panel.compact .pole-zero-list {
            display: none;
        }
        canvas {
            display: block;
            margin: 15px auto;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
            font-size: 0.9em;
        }
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em;
        }
        input[type="range"] {
            padding: 0;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #3498db;
            font-weight: 600;
        }
        .formula {
            background: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            text-align: center;
            color: #2c3e50;
        }
        .stability-indicator {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin-top: 10px;
        }
        .stable {
            background: #d4edda;
            color: #155724;
        }
        .unstable {
            background: #f8d7da;
            color: #721c24;
        }
        .marginal {
            background: #fff3cd;
            color: #856404;
        }
        .pole-zero-list {
            font-size: 0.9em;
            line-height: 1.6;
            color: #555;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Zurück zur Digitalen Verarbeitung</a>

    <div class="container">
        <h1>Z-Transformation (Z-Transform)</h1>
        <div class="subtitle">Pole, Nullstellen und Stabilität digitaler Systeme</div>

        <div class="info-box">
            <h3>Die Z-Transformation</h3>
            <p>
                Die Z-Transformation ist das diskrete Gegenstück zur Laplace-Transformation und beschreibt
                digitale Systeme durch ihre <strong>Übertragungsfunktion H(z)</strong> im z-Bereich.
                Ein System ist <strong>stabil</strong>, wenn alle <strong>Pole</strong> innerhalb des Einheitskreises liegen.
            </p>
            <div class="formula">
                H(z) = Y(z)/X(z) = (b₀ + b₁z⁻¹ + ... + b_Mz⁻ᴹ) / (a₀ + a₁z⁻¹ + ... + a_Nz⁻ᴺ)
            </div>
            <p style="margin-top: 15px; font-size: 0.95em; color: #666;">
                <strong>Pole (×):</strong> Lösungen des Nenners (Pole der Übertragungsfunktion) bestimmen Stabilität<br>
                <strong>Nullstellen (○):</strong> Lösungen des Zählers bestimmen Frequenzselektion<br>
                <strong>Einheitskreis:</strong> Grenze zwischen stabilen (innen) und instabilen (außen) Polen
            </p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>
                    Filtertyp:
                </label>
                <select id="filterType">
                    <option value="lowpass">Tiefpass (Lowpass)</option>
                    <option value="highpass">Hochpass (Highpass)</option>
                    <option value="bandpass">Bandpass</option>
                    <option value="notch">Notch (Bandsperre)</option>
                    <option value="resonator">Resonator</option>
                    <option value="allpass">Allpass</option>
                    <option value="unstable">Instabiles System</option>
                    <option value="custom">Benutzerdefiniert</option>
                </select>
            </div>

            <div class="control-group" id="poleControls">
                <label>
                    Polradius r: <span class="value-display" id="poleRadiusValue">0.8</span>
                </label>
                <input type="range" id="poleRadius" min="0" max="1.2" step="0.01" value="0.8">
            </div>

            <div class="control-group" id="angleControls">
                <label>
                    Polwinkel θ: <span class="value-display" id="poleAngleValue">45°</span>
                </label>
                <input type="range" id="poleAngle" min="0" max="180" step="1" value="45">
            </div>

            <div class="control-group">
                <label>
                    Anzahl FFT-Punkte:
                </label>
                <select id="fftSize">
                    <option value="128">128</option>
                    <option value="256" selected>256</option>
                    <option value="512">512</option>
                </select>
            </div>
        </div>

        <div class="grid-container">
            <div class="panel compact">
                <h3>Pol-Nullstellen-Diagramm (Pole-Zero Plot)</h3>
                <canvas id="pzCanvas" width="360" height="360"></canvas>
                <div style="text-align: center;">
                    <div id="stabilityIndicator" class="stability-indicator stable">STABIL</div>
                </div>
                <div class="pole-zero-list" id="poleZeroList"></div>
            </div>

            <div class="panel">
                <h3>Frequenzgang (Frequency Response)</h3>
                <canvas id="magCanvas" width="500" height="200"></canvas>
                <canvas id="phaseCanvas" width="500" height="200"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>Impulsantwort h[n] (Impulse Response)</h3>
            <canvas id="impulseCanvas" width="1040" height="250"></canvas>
        </div>

        <div class="formula" id="transferFunction"></div>


        <div class="related-topics">
            <h4>Verwandte Themen</h4>
            <a href="digitale_filter.html">→ IIR-Filter (Pol-Nullstellen-Design)</a>
            <a href="frequenzanalyse/fourier_transformation.html">→ Frequenzgang H(e^jω)</a>
            <a href="fensterfunktionen.html">→ Spektralanalyse</a>
        </div>

        <div class="common-mistake">
            <h4>Merken</h4>
            <p><strong>Stabilität:</strong> Alle Pole innerhalb Einheitskreis (|z| &lt; 1)</p>
            <p>Nullstellen → Amplitude | Pole → Amplitude + Stabilität</p>
        </div>

        <div class="export-controls">
            <button class="export-btn" onclick="exportPNG()">Visualisierung speichern</button>
        </div>
    </div>

    <script>
        const pzCanvas = document.getElementById('pzCanvas');
        const magCanvas = document.getElementById('magCanvas');
        const phaseCanvas = document.getElementById('phaseCanvas');
        const impulseCanvas = document.getElementById('impulseCanvas');

        const pzCtx = pzCanvas.getContext('2d');
        const magCtx = magCanvas.getContext('2d');
        const phaseCtx = phaseCanvas.getContext('2d');
        const impulseCtx = impulseCanvas.getContext('2d');

        const filterTypeSelect = document.getElementById('filterType');
        const poleRadiusSlider = document.getElementById('poleRadius');
        const poleAngleSlider = document.getElementById('poleAngle');
        const fftSizeSelect = document.getElementById('fftSize');

        let poles = [];
        let zeros = [];
        let customMode = false;

        // Vordefinierte Filter
        const filterPresets = {
            lowpass: {
                poles: [{r: 0.8, theta: Math.PI/4}, {r: 0.8, theta: -Math.PI/4}],
                zeros: [{r: 1, theta: Math.PI}, {r: 1, theta: -Math.PI}]
            },
            highpass: {
                poles: [{r: 0.8, theta: Math.PI/4}, {r: 0.8, theta: -Math.PI/4}],
                zeros: [{r: 1, theta: 0}, {r: 1, theta: 0}]
            },
            bandpass: {
                poles: [{r: 0.9, theta: Math.PI/3}, {r: 0.9, theta: -Math.PI/3}],
                zeros: [{r: 1, theta: 0}, {r: 1, theta: Math.PI}]
            },
            notch: {
                poles: [{r: 0.85, theta: Math.PI/2}, {r: 0.85, theta: -Math.PI/2}],
                zeros: [{r: 1, theta: Math.PI/2}, {r: 1, theta: -Math.PI/2}]
            },
            resonator: {
                poles: [{r: 0.95, theta: Math.PI/3}, {r: 0.95, theta: -Math.PI/3}],
                zeros: []
            },
            allpass: {
                poles: [{r: 0.7, theta: Math.PI/4}, {r: 0.7, theta: -Math.PI/4}],
                zeros: [{r: 1/0.7, theta: Math.PI/4}, {r: 1/0.7, theta: -Math.PI/4}]
            },
            unstable: {
                poles: [{r: 1.2, theta: Math.PI/4}, {r: 1.2, theta: -Math.PI/4}],
                zeros: [{r: 1, theta: Math.PI/2}, {r: 1, theta: -Math.PI/2}]
            }
        };

        function loadFilter(type) {
            if (type === 'custom') {
                customMode = true;
                updateCustomFilter();
            } else {
                customMode = false;
                const preset = filterPresets[type];
                poles = preset.poles.map(p => ({...p}));
                zeros = preset.zeros.map(z => ({...z}));
            }
            draw();
        }

        function updateCustomFilter() {
            const r = parseFloat(poleRadiusSlider.value);
            const theta = parseFloat(poleAngleSlider.value) * Math.PI / 180;

            poles = [{r: r, theta: theta}, {r: r, theta: -theta}];
            zeros = [{r: 1, theta: 0}, {r: 1, theta: Math.PI}];

            draw();
        }

        function polarToComplex(r, theta) {
            return {
                re: r * Math.cos(theta),
                im: r * Math.sin(theta)
            };
        }

        function complexMultiply(a, b) {
            return {
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            };
        }

        function complexSubtract(a, b) {
            return {
                re: a.re - b.re,
                im: a.im - b.im
            };
        }

        function complexDivide(a, b) {
            const denom = b.re * b.re + b.im * b.im;
            return {
                re: (a.re * b.re + a.im * b.im) / denom,
                im: (a.im * b.re - a.re * b.im) / denom
            };
        }

        function complexMagnitude(c) {
            return Math.sqrt(c.re * c.re + c.im * c.im);
        }

        function complexPhase(c) {
            return Math.atan2(c.im, c.re);
        }

        function evaluateH(omega) {
            const z = {re: Math.cos(omega), im: Math.sin(omega)};

            let numerator = {re: 1, im: 0};
            for (let zero of zeros) {
                const zeroPoint = polarToComplex(zero.r, zero.theta);
                const diff = complexSubtract(z, zeroPoint);
                numerator = complexMultiply(numerator, diff);
            }

            let denominator = {re: 1, im: 0};
            for (let pole of poles) {
                const polePoint = polarToComplex(pole.r, pole.theta);
                const diff = complexSubtract(z, polePoint);
                denominator = complexMultiply(denominator, diff);
            }

            return complexDivide(numerator, denominator);
        }

        function calculateImpulseResponse(length) {
            // Berechne Impulsantwort durch Filterung eines Einheitsimpulses
            // Konvertiere Pole/Nullstellen zu Koeffizienten und nutze Differenzengleichung

            const h = new Array(length).fill(0);
            const x = new Array(length).fill(0);
            x[0] = 1; // Einheitsimpuls δ[n]

            // Berechne Nenner- und Zählerkoeffizienten aus Polen und Nullstellen
            // H(z) = (Produkt (z - z_i)) / (Produkt (z - p_i))

            // Für reale Implementation: verwende rekursive Filterung
            // y[n] = (1/a[0]) * (Σ b[k]x[n-k] - Σ a[k]y[n-k])

            // Vereinfachte Implementierung für bis zu 2 Pole/Nullstellen
            const a = [1]; // Nennerkoeffizienten
            const b = [1]; // Zählerkoeffizienten

            // Expandiere Pole zu Koeffizienten (z - p)(z - p*)
            if (poles.length >= 2) {
                const p1 = polarToComplex(poles[0].r, poles[0].theta);
                const p2 = polarToComplex(poles[1].r, poles[1].theta);

                // (z - p1)(z - p2) = z^2 - (p1+p2)z + p1*p2
                // Als z^-1 Form: 1 - (p1+p2)z^-1 + p1*p2 z^-2
                a.push(-(p1.re + p2.re));
                a.push(p1.re * p2.re - p1.im * p2.im);
            } else if (poles.length === 1) {
                const p = polarToComplex(poles[0].r, poles[0].theta);
                a.push(-p.re * 2); // Konjugiert komplex
                a.push(poles[0].r * poles[0].r);
            }

            // Expandiere Nullstellen zu Koeffizienten
            if (zeros.length >= 2) {
                const z1 = polarToComplex(zeros[0].r, zeros[0].theta);
                const z2 = polarToComplex(zeros[1].r, zeros[1].theta);

                b.push(-(z1.re + z2.re));
                b.push(z1.re * z2.re - z1.im * z2.im);
            } else if (zeros.length === 1) {
                const z = polarToComplex(zeros[0].r, zeros[0].theta);
                b.push(-z.re * 2);
                b.push(zeros[0].r * zeros[0].r);
            }

            // Rekursive Filterung: y[n] = Σ b[k]x[n-k] - Σ a[k]y[n-k]
            for (let n = 0; n < length; n++) {
                let sum = 0;

                // Feedforward (Zähler)
                for (let k = 0; k < b.length; k++) {
                    if (n - k >= 0) {
                        sum += b[k] * x[n - k];
                    }
                }

                // Feedback (Nenner)
                for (let k = 1; k < a.length; k++) {
                    if (n - k >= 0) {
                        sum -= a[k] * h[n - k];
                    }
                }

                h[n] = sum / a[0];
            }

            return h;
        }

        function checkStability() {
            for (let pole of poles) {
                if (pole.r > 1.0) return 'unstable';
                if (Math.abs(pole.r - 1.0) < 0.02) return 'marginal';
            }
            return 'stable';
        }

        function drawPoleZeroPlot() {
            const ctx = pzCtx;
            const w = pzCanvas.width;
            const h = pzCanvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) / 2 - 40;

            ctx.clearRect(0, 0, w, h);

            // Gitter
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i += 0.5) {
                // Vertikale Linien
                ctx.beginPath();
                ctx.moveTo(cx + i * radius, 40);
                ctx.lineTo(cx + i * radius, h - 40);
                ctx.stroke();
                // Horizontale Linien
                ctx.beginPath();
                ctx.moveTo(40, cy + i * radius);
                ctx.lineTo(w - 40, cy + i * radius);
                ctx.stroke();
            }

            // Achsen
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, cy);
            ctx.lineTo(w - 40, cy);
            ctx.moveTo(cx, 40);
            ctx.lineTo(cx, h - 40);
            ctx.stroke();

            // Einheitskreis
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();

            // Beschriftungen
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Re', w - 25, cy - 10);
            ctx.fillText('Im', cx + 15, 30);
            ctx.fillText('1', cx + radius + 15, cy + 5);
            ctx.fillText('-1', cx - radius - 15, cy + 5);

            // Nullstellen (Kreise)
            ctx.strokeStyle = '#e74c3c';
            ctx.fillStyle = '#e74c3c';
            ctx.lineWidth = 2;
            for (let zero of zeros) {
                const pt = polarToComplex(zero.r, zero.theta);
                const x = cx + pt.re * radius;
                const y = cy - pt.im * radius;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.stroke();
            }

            // Pole (Kreuze)
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            for (let pole of poles) {
                const pt = polarToComplex(pole.r, pole.theta);
                const x = cx + pt.re * radius;
                const y = cy - pt.im * radius;
                const size = 10;
                ctx.beginPath();
                ctx.moveTo(x - size, y - size);
                ctx.lineTo(x + size, y + size);
                ctx.moveTo(x - size, y + size);
                ctx.lineTo(x + size, y - size);
                ctx.stroke();
            }

            // Legende
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('○ Nullstellen (Zeros)', 50, h - 20);
            ctx.fillStyle = '#3498db';
            ctx.fillText('× Pole', 220, h - 20);
        }

        function drawFrequencyResponse() {
            const fftSize = parseInt(fftSizeSelect.value);
            const frequencies = [];
            const magnitudes = [];
            const phases = [];

            for (let k = 0; k < fftSize / 2; k++) {
                const omega = 2 * Math.PI * k / fftSize;
                frequencies.push(omega);
                const H = evaluateH(omega);
                magnitudes.push(complexMagnitude(H));
                phases.push(complexPhase(H));
            }

            // Magnitude
            drawMagnitude(frequencies, magnitudes);
            // Phase
            drawPhase(frequencies, phases);
        }

        function drawMagnitude(frequencies, magnitudes) {
            const ctx = magCtx;
            const w = magCanvas.width;
            const h = magCanvas.height;
            const margin = {top: 30, right: 30, bottom: 40, left: 60};
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;

            ctx.clearRect(0, 0, w, h);

            // Hintergrund
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(margin.left, margin.top, plotW, plotH);

            // Titel
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Amplitudengang |H(e^jω)|', w / 2, 20);

            // Gitter
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + (plotH * i) / 5;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + plotW, y);
                ctx.stroke();
            }

            // Achsen
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.stroke();

            // Beschriftung
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            const maxMag = Math.max(...magnitudes, 2);
            for (let i = 0; i <= 5; i++) {
                const val = maxMag - (maxMag * i) / 5;
                const y = margin.top + (plotH * i) / 5;
                ctx.fillText(val.toFixed(1), margin.left - 5, y + 4);
            }

            ctx.textAlign = 'center';
            ctx.fillText('0', margin.left, h - 10);
            ctx.fillText('π', margin.left + plotW, h - 10);
            ctx.fillText('Frequenz ω', w / 2, h - 5);

            // Kurve
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < frequencies.length; i++) {
                const x = margin.left + (frequencies[i] / Math.PI) * plotW;
                const y = margin.top + plotH - (magnitudes[i] / maxMag) * plotH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawPhase(frequencies, phases) {
            const ctx = phaseCtx;
            const w = phaseCanvas.width;
            const h = phaseCanvas.height;
            const margin = {top: 30, right: 30, bottom: 40, left: 60};
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;

            ctx.clearRect(0, 0, w, h);

            // Hintergrund
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(margin.left, margin.top, plotW, plotH);

            // Titel
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Phasengang ∠H(e^jω)', w / 2, 20);

            // Gitter
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = margin.top + (plotH * i) / 4;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + plotW, y);
                ctx.stroke();
            }

            // Achsen
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.stroke();

            // Beschriftung
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            const labels = ['π', 'π/2', '0', '-π/2', '-π'];
            for (let i = 0; i <= 4; i++) {
                const y = margin.top + (plotH * i) / 4;
                ctx.fillText(labels[i], margin.left - 5, y + 4);
            }

            ctx.textAlign = 'center';
            ctx.fillText('0', margin.left, h - 10);
            ctx.fillText('π', margin.left + plotW, h - 10);
            ctx.fillText('Frequenz ω', w / 2, h - 5);

            // Kurve
            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < frequencies.length; i++) {
                const x = margin.left + (frequencies[i] / Math.PI) * plotW;
                const normalized = ((phases[i] + Math.PI) / (2 * Math.PI)); // 0 bis 1
                const y = margin.top + plotH * (1 - normalized);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawImpulseResponse() {
            const ctx = impulseCtx;
            const w = impulseCanvas.width;
            const h = impulseCanvas.height;
            const margin = {top: 30, right: 30, bottom: 40, left: 60};
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;

            ctx.clearRect(0, 0, w, h);

            // Hintergrund
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(margin.left, margin.top, plotW, plotH);

            // Titel
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Impulsantwort h[n]', w / 2, 20);

            const length = 50;
            const h_n = calculateImpulseResponse(length);
            const maxVal = Math.max(...h_n.map(Math.abs), 0.1);

            // Gitter
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + (plotH * i) / 5;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + plotW, y);
                ctx.stroke();
            }

            // Achsen
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            const zeroY = margin.top + plotH / 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.moveTo(margin.left, zeroY);
            ctx.lineTo(margin.left + plotW, zeroY);
            ctx.stroke();

            // Beschriftung Y-Achse
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = maxVal - (2 * maxVal * i) / 5;
                const y = margin.top + (plotH * i) / 5;
                ctx.fillText(val.toFixed(2), margin.left - 5, y + 4);
            }

            // Balken
            const barWidth = plotW / length;
            for (let n = 0; n < length; n++) {
                const x = margin.left + n * barWidth;
                const barHeight = (h_n[n] / maxVal) * (plotH / 2);
                const y = zeroY - barHeight;

                ctx.fillStyle = h_n[n] >= 0 ? '#3498db' : '#e74c3c';
                ctx.fillRect(x + 1, Math.min(y, zeroY), barWidth - 2, Math.abs(barHeight));
            }

            // X-Achse Beschriftung
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('0', margin.left, h - 10);
            ctx.fillText(length.toString(), margin.left + plotW, h - 10);
            ctx.fillText('n', w / 2, h - 5);
        }

        function updateStabilityIndicator() {
            const stability = checkStability();
            const indicator = document.getElementById('stabilityIndicator');

            indicator.className = 'stability-indicator ' + stability;
            if (stability === 'stable') {
                indicator.textContent = 'STABIL (alle Pole innerhalb)';
            } else if (stability === 'marginal') {
                indicator.textContent = 'GRENZSTABIL (Pole auf Einheitskreis)';
            } else {
                indicator.textContent = 'INSTABIL (Pole außerhalb)';
            }
        }

        function updatePoleZeroList() {
            const list = document.getElementById('poleZeroList');
            let html = '<strong>Pole:</strong><br>';

            poles.forEach((p, i) => {
                const pt = polarToComplex(p.r, p.theta);
                html += `P${i+1}: ${pt.re.toFixed(3)} ${pt.im >= 0 ? '+' : ''}${pt.im.toFixed(3)}j (r=${p.r.toFixed(3)})<br>`;
            });

            html += '<br><strong>Nullstellen:</strong><br>';
            zeros.forEach((z, i) => {
                const pt = polarToComplex(z.r, z.theta);
                html += `Z${i+1}: ${pt.re.toFixed(3)} ${pt.im >= 0 ? '+' : ''}${pt.im.toFixed(3)}j (r=${z.r.toFixed(3)})<br>`;
            });

            list.innerHTML = html;
        }

        function draw() {
            drawPoleZeroPlot();
            drawFrequencyResponse();
            drawImpulseResponse();
            updateStabilityIndicator();
            updatePoleZeroList();
        }

        // Event Listeners
        filterTypeSelect.addEventListener('change', (e) => {
            loadFilter(e.target.value);
            document.getElementById('poleControls').style.display =
                e.target.value === 'custom' ? 'block' : 'none';
            document.getElementById('angleControls').style.display =
                e.target.value === 'custom' ? 'block' : 'none';
        });

        poleRadiusSlider.addEventListener('input', (e) => {
            document.getElementById('poleRadiusValue').textContent = e.target.value;
            if (customMode) updateCustomFilter();
        });

        poleAngleSlider.addEventListener('input', (e) => {
            document.getElementById('poleAngleValue').textContent = e.target.value + '°';
            if (customMode) updateCustomFilter();
        });

        fftSizeSelect.addEventListener('change', draw);

        // Initial
        document.getElementById('poleControls').style.display = 'none';
        document.getElementById('angleControls').style.display = 'none';
        loadFilter('lowpass');


        // ===== Export-Funktionen =====
        function exportPNG() {
            const canvas = document.querySelector('canvas');
            if (!canvas) return;
            const link = document.createElement('a');
            link.download = 'visualisierung.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
